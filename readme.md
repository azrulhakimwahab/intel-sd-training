# Intel SD Training 

## Table of contents
+ **[ Day 0 - System/Tool Setup Check. GitHub ID creation ](https://github.com/teoh5128/intel-sd-training#day-0)**
  <details><summary> Theory </summary>
  
  [Theory - System/Tool Setup Check. GitHub ID creation](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---systemtool-setup-check-github-id-creation)
  </details>
  <details><summary> Lab </summary>
  
  * [ Lab -Setup Labs](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#steps-to-enable-labs)
  </details>
  
- **[ Day 1 - Introduction to Verilog RTL design and Synthesis](https://github.com/teoh5128/intel-sd-training#day-1)**
  <details><summary> Theory </summary>
  
  [Theory - Introduction to Verilog RTL design and Synthesis](https://github.com/teoh5128/intel-sd-training#theory---introduction-to-verilog-rtl-design-and-synthesis)
  
  </details>
  <details><summary> Lab </summary>
  
  * [Lab - SKY130RTL D1SK2 L1 Lab1 introduction to lab](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d1sk2-l1-lab1-introduction-to-lab) 
  * [Lab - SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d1sk2-l2-lab2-introduction-iverilog-gtkwave-part1)
  * [Lab - SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d1sk2-l2-lab2-introduction-iverilog-gtkwave-part2)
  * [Lab - SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d1sk4-l1-lab3-yosys-1-good-mux-part1)
  * [Lab - SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d1sk4-l1-lab3-yosys-1-good-mux-part2)
  * [Lab - SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part3](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d1sk4-l1-lab3-yosys-1-good-mux-part3)
  
+ **[ Day 2 - Timing libs(QTMs/ETMs), hierarchical vs flat synthesis and efficient flop coding styles](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#day-2)**
  <details><summary> Theory </summary>
    
   [Theory - Timing libs(QTMs/ETMs), hierarchical vs flat synthesis and efficient flop coding styles](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---timing-libsqtmsetms-hierarchical-vs-flat-synthesis-and-efficient-flop-coding-styles)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab - SKY130RTL D2SK1 L1 Lab4 Introduction to dot Lib part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk1-l1-lab4-introduction-to-dot-lib-part1)
  * [Lab - SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk1-l2-lab4-introduction-to-dot-lib-part2)
  * [Lab - SKY130RTL D2SK1 L3 Lab4 Introduction to dot Lib part3](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk1-l3-lab4-introduction-to-dot-lib-part3)
  * [Lab - SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk2-l1-lab05-hier-synthesis-flat-synthesis-part1)
  * [Lab - SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk2-l2-lab05-hier-synthesis-flat-synthesis-part2)
  * [Lab - SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk3-l3-lab-flop-synthesis-simulations-part1)
  * [Lab - SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk3-l4-lab-flop-synthesis-simulations-part2)
  * [Lab - SKY130RTL D2SK3 L5 Interesting optimisations part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk3-l5-interesting-optimisations-part1)
  * [Lab - SKY130RTL D2SK3 L5 Interesting optimisations part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d2sk3-l5-interesting-optimisations-part2)
   </details>
  
- **[ Day 3 - Combinational and sequential optmizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#day-3)**
  <details><summary> Theory </summary>
    
    [Theory - Combinational and sequential optmizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---combinational-and-sequential-optmizations)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab - SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d3sk2-l1-lab06-combinational-logic-optimisations-part1)
  * [Lab - SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d3sk2-l2-lab06-combinational-logic-optimisations-part2)
  * [Lab - SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d3sk2-l2-lab06-combinational-logic-optimisations-exercise)
  * [Lab - SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d3sk3-l1-lab07-sequential-logic-optimisations-part1)
  * [Lab - SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d3sk3-l2-lab07-sequential-logic-optimisations-part2)
  * [Lab -SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab--sky130rtl-d3sk3-l3-lab07-sequential-logic-optimisations-part3)
  * [Lab -SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab--sky130rtl-d3sk3-l3-lab07-sequential-logic-optimisations-part3-exercise)
  * [Lab - SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d3sk4-l1-seq-optimisation-unused-outputs-part1)
  * [Lab - SKY130RTL D3SK4 L2 Seq optimisation unused outputs part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d3sk4-l2-seq-optimisation-unused-outputs-part2)
  
  </details>
  
+ **[ Day 4 - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#day-4))**
  <details><summary> Theory </summary>
    
   [Theory - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---gls-blocking-vs-non-blocking-and-synthesis-simulation-mismatch)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab - SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d4sk2-l1-lab-gls-synth-sim-mismatch-part1)
  * [Lab - SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d4sk2-l2-lab-gls-synth-sim-mismatch-part2)
  * [Lab - SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement part1](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d4sk3-l1-lab-synth-sim-mismatch-blocking-statement-part1)
  * [Lab - SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d4sk3-l2-lab-synth-sim-mismatch-blocking-statement-part2)
  
  </details>
 
 
- **[ Day 5 - DFT(Design for Testability)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#day-6)**
  
  <details><summary> Theory </summary>
    
  * [Theory - DFT (Design for Testability)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---dft-design-for-testability)
    
  </details>
 
  
+ **[ Day 6 - Introduction to Logic Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#day-6))**
  <details><summary> Theory </summary>
    
  * [Theory - Introduction to Logic Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---introduction-to-logic-synthesis)
  * [Theory - Introduction to Design Compiler (DC)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---introduction-to-design-compiler-dc)
  * [Theory - TCL quick refresher](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#theory---tcl-quick-refresher)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab - DC_D1SK2_L1 - lab1 - Invoking dc basic setup](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---dc_d1sk2_l1---lab1---invoking-dc-basic-setup)
  * [Lab - DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---dc_d1sk2_l2---lab2---intro-to-ddc-gui-with-design_vision)
  * [Lab - DC_D1SK2_L3 - lab3 - dc synopsys dc setup](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---dc_d1sk2_l3---lab3---dc-synopsys-dc-setup)
  * [Lab - DC_D1SK3_L2 - lab4 - tcl scripting](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---dc_d1sk3_l2---lab4---tcl-scripting)
    
  </details>
  
  
## Day 0
## Theory - System/Tool Setup Check. GitHub ID creation

<details><summary> Package </summary>
 
### **Package**
Package is a container that holds die and was connected to outside (external device) by using wire bonding.
Example of package - Quadruple in-line package (QIP) and Dual in-line package (DIP).

![die](https://user-images.githubusercontent.com/62828746/203833674-a44e1aa2-42f1-43eb-8890-016e0bc186e1.png)

* **Pad** - used to connect inside (core) to outside (I/O), good at ESD protection to prevent charge coming from outside damage the core inside.
* **Core** - consists of all the main logic gate (NMOS/PMOS) and cell block such as macro cell and foundry IP's.
* **I/O** - help in communication between die with external and will be connected to die by using wire bonding.

+ **Differences of macro vs foundry IP's**:
  * **Macro** - a simple core/cell with simple functionality and can be easily found online.
  * **Foundry IP's** - cell with more specific functionality and the design was patent/owned by a company. Has higher value compared to macro.
  
  </details>

<details><summary> How does a software communicate with hardware</summary>

### **How does a software communicate with hardware**
**Synthesis process** will help to convert software's instructions which is written in high level language to gate level language/machine language which is normally in binary format.

![software to hardware](https://user-images.githubusercontent.com/62828746/203840905-0b291241-5af6-40d1-9f6a-a8acb8176b7d.png)
 
**Synthesis process flow**:
1. **Specification/instructions** written in RTL (**high-level language** such as C, C++ or Java) as inputs.
1. **Compiler** will compile the instruction into **assembly language** (.exe).
1. **Assembler** will then convert **assembly language** into **gate level language** (low-level language.machine language) which is in binary format (operands), and it is the language understood by a computer.

   </details>

## Lab - Setup Labs

<details open><summary> Steps to enable labs </summary>
 
#### Steps to enable labs:

* [Day0 Lab Steps](https://intel-my.sharepoint.com/:u:/r/personal/huifen_teoh_intel_com/Documents/Desktop/Intel_SD_Training/Lab/Day0_lab.msg?csf=1&web=1&e=Kat8QI)

#### Result:

![Day0 Lab Result](https://user-images.githubusercontent.com/62828746/203844716-f72c32ab-2353-4f42-bbd2-c3bb49c88ecb.PNG)
 
   </details>


## Day 1
## Theory - Introduction to Verilog RTL design and Synthesis

<details><summary> HDL (Hardware description Language) </summary>

### **HDL (Hardware description Language)**
* It is a language that used to model electronic circuit/system by describing their structure and behavior precisely.
* Commonly used in the design and verification of digital circuit.
* Most widely used and well-supported HDL used in industry: **Verilog** and VHDL (VHSIC Hardware Description Language)
* HDL code can be written in 3 model/levels of abstraction. (Behavioural, RTL and Gate-level)
   </details>
 
<details><summary> RTL Design (Register Transfer Level) </summary>
  
### **RTL Design (Register Transfer Level)**
* It's a design abstraction which models the signal flow between hardware registers and also the logical operations that performed on those signals.
* RTL written in Verilog decribes how signal is changed as it passed from register to register. 
* In shorts, HDL is a language used to decribe circuit's specification (structure and bahaviour) while RTL is a way of describing the circuit. 
   </details>
 
<details><summary> Synthesis </summary>
 
### **Synthesis**
* Synthesis tool (synthesizer) will turning an abstract design (**RTL**) into a correctly implmented chip in term of logic gates (**netlist**).
* Translation - Translate Verilog that describe design specification/functionality into basic logic gates.
* Mapping - Map logic gates to actual technology dependent logic gate that are readily avaiable in tech file.
* Optimization - Optimized mapped netlist while maintaining design's specification/functionality.

   </details>

<details><summary> Testbench </summary>
 
### **Testbench**

![testbench](https://user-images.githubusercontent.com/62828746/205500508-8e14ec1a-86b0-443f-aa71-f6570a717609.jpg)

* **Testbench** - is a setup to apply stimulus to the design and check whether the output meet required functionality and specification.
* **Stimulator** - it will apply stimulus to design input (stimulus generator) and obseve stimulus from design output (stimulus observer).
* **Design** - a verilog code/ a set of verilog codes that has intended functionality to meet required specification (Ex: an inverter).

   </details>

<details><summary> iVerilog (Icarus Verilog) Based RTL Design Simulation Flow </summary>
 
### **iVerilog (Icarus Verilog) Based RTL Design Simulation Flow**

**iVerilog** - is an open source verilog simulator tool that used to check design specification is adherence to RTL design or not.

![iVerilog Based Simulation Flow_1a](https://user-images.githubusercontent.com/62828746/205515413-06107299-7637-4000-a983-5ab9c8d46210.jpg)

1. **RTL design** and **testbench** are applied to iVerilog as inputs.
2. **iVerilog** simulating the design while any changes in value will be generated as VCD file.
3. **GTKwave** which is a graphic application helps in viewing the waveform.
4. Through the waveform, we can observe whether the input and output meet design specification. 

   </details>

<details><summary> yosys (Yosys Open SYnthesis Suite) Based Synthesis Flow </summary>
 
### **yosys (Yosys Open SYnthesis Suite) Based Synthesis Flow**

**yosys** is a framework for RTL synthesis tools that is used to convert RTL to netlist.

![yosys synthesizer_0](https://user-images.githubusercontent.com/62828746/205504038-a06b8354-b6de-4f03-96fe-faca348a5c34.jpg)

* **Design** - it's a behaviour verilog code.
* **.lib** - a collection of standard cell/logical modules. It includes basic logic gates (Ex: AND,OR,NAND,NOR) of different flavor such as number of inputs, speeds (slow, medium or fast) and functionality.
* **Netlist** - it's the representation of design in term of standard cell stored in the .lib.

   </details>

 <details><summary> iVerilog (Icarus Verilog) Based Synthesized Netlist Simulation Flow </summary>
  
### **iVerilog (Icarus Verilog) Based Synthesized Netlist Simulation Flow**

To confirm the netlist generated in synthesis is meet the requirement, will need to verify the netlist by using the simulator tool.

![iVerilog Based Synthesized Netlist Simulation Flow_0](https://user-images.githubusercontent.com/62828746/205505409-509251fa-7141-44ae-9b70-05ff0b15d704.jpg)

**Simulation flow** and the **outputs waveform** for both RTL design and synthesized netlist will be the same. The only difference is the inputs (RTL design[.v] or synthesized netlist[netlist.v]).

1. **Netlist** and **testbench** are applied to iVerilog as inputs.
2. **iVerilog** simulating the design while any changes in value will be generated as VCD file.
3. **GTKwave** which is a graphic application helps in viewing the waveform.
4. Through the waveform, we can observe whether the input and output meet design specification. 

   </details>
 
 <details><summary> How Flavours of Gate Effect Ciruit Operation Speed </summary>
  
### **How Flavours of Gate Effect Ciruit Operation Speed**

Combinational delay in logic path determine the maximum operation speed of digital logic circuit.

![Flavours of Gate (Fast vs Slow)](https://user-images.githubusercontent.com/62828746/205507225-0ab7c70d-3752-4aa8-8e97-dcf57d984a3f.jpg)

* The **minimum clock period** must be larger than the total time taken for propogation delay in both DFF A and combinational logic and setup time in DFF B.
* Minimum clock period signal let signals have enough time to travel from DFF A to DFF B.
* Better performance circuit must have **low clock period** and **high clock frequency**, so that operation speed will be higher.
* High speed standard cells can help in reduce propogation delay and thus reduce overall clock period.
* However, high speed cells might cause DFF B capture signal too fast and missed the data that supposed to catch.
* For this reason, hold time is required to have minimum delay from DFF A to DFF B.
* Slower cells can help in meeting the required hold time.
* In shorts, we need **fast cells to meet required performance** and also need **slow cells to meet minimum hold time**.

   </details>

<details><summary> How Capacitance Effect Circuit's Speed* </summary>
 
### **How Capacitance Effect Circuit's Speed**

![How Capacitance Effect Circuit's Speed](https://user-images.githubusercontent.com/62828746/205509103-b8a090bb-48eb-4854-abff-5e7c4500ab87.jpg)

* **Capacitance** - it's a load in digital logic ciruit. Faster charging/discharging rate will reduce cell delay and make cell A to drive cell B faster.
* **Transistor** - Wider transistor has higher capable of sourcing larger current and will result in faster capacitance charging/discharging rate. However, will wider transistor will consume larger area and power.

* In shorts, faster cells need to trade off with **area and power**.

   </details>

<details><summary> Cell Selection and Trade Off </summary>
  
### **Cell Selection and Trade Off**

Synthesizer required **constraints** as guidance in cell selection to select correct cell flavour that is optimum for logic circuit implementation.

Trade Off for Fast Cell                          | Trade off for Slow Cell
---------------------------------------------    | --------------------------------------------- 
Bad ciruit in term of area and power             | Slow speed circuit
Concern in hold time violation                   | Failed required performance

  </details>

## Lab Topic-  SKY130RTL D1SK2 Labs using iverilog and gtkwave
<details open><summary> SKY130RTL D1SK2 L1 Lab1 introduction to lab </summary>
 
### Lab - SKY130RTL D1SK2 L1 Lab1 introduction to lab

#### Steps:

> 1. Clone directory "sky130RTLDesignAndSynthesisWorkshop" from Kunal's github.
> > *git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git*
> 2. Explore copied directory and confirm there's all the required folders and files.
> > *cd sky130RTLDesignAndSynthesisWorkshop/*
> 3. Goto my_lib/ to explore stored verilog model.
> > *cd my_lib/*
> 4. Goto lib/ and make sure "sky130_fd_sc_hd__tt_025C_1v80.lib" lib is inside.
> > *cd lib/*
> 5. Goto verilog_files which stored all the verilog and testbench fill that will be used in subsequent labs.
>> *cd verilog_files/*

#### Result:
![SKY130RTL D1SK2 L1 Lab1 introduction to lab_result](https://user-images.githubusercontent.com/62828746/205509273-3c3774d7-75c2-4293-8306-29d9af55b0c8.jpg)

  </details>
 
 ## Lab Topic- SKY130RTL D1SK4 Labs using Yosys and Sky130 PDKs
  
<details open><summary> SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1 </summary>
  
### Lab - SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1
Related with theory part: [iVerilog (Icarus Verilog) Based RTL Design Simulation Flow](https://github.com/teoh5128/intel-sd-training/edit/main/readme.md#iverilog-icarus-verilog-based-synthesized-netlist-simulation-flow)

#### Steps:
> 1. Take good_mux cell as example. Run simulation by apply RTL Design (good_mux.v) and testbench (tb_good_mux.v) as inputs.
> > *iverilog good_mux.v tb_good_mux.v*
> 2. a.out file is now created, then exectue a.out file to dump vcd file.
> > *./a.out*

#### Result:
![SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1_result_1](https://user-images.githubusercontent.com/62828746/205509351-9d96c79a-bd4b-4f1e-b1cb-4f00a4f974c0.jpg)

#### Steps:
> 1. Load generated vcd file in graphic application, GTKwave.
> > *gtkwave tb_good_mux.vcd*
> 2. Review waveform in GTKwave after pull all the signals to "signal" column and zoom to fit.

![SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1_result_2_a](https://user-images.githubusercontent.com/62828746/205514717-bdef7d9c-0f8a-4c13-a65e-58a95c6f1df0.jpg)
  </details>
  
<details open><summary> SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part2  </summary>
  
### Lab - SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part2

#### Steps:
> 1. Explore verilog file and testbench file to compare it with generated waveform.
>> *vim tb_good_mux.v -o good_mux.v*
> 2. Review generated waveform, result must follow all the specification in verilog and testbench.

#### Result:
![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_1](https://user-images.githubusercontent.com/62828746/205509398-b41f44e7-e9e7-445a-8a4d-e79a5a9e11bf.jpg)
*Testbench contains design instantiation (UUT) and will not have primary inputs/outputs assigned.*

![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_3_0](https://user-images.githubusercontent.com/62828746/205514404-3c9b3de8-51e6-4135-9a5a-41bcff2d1d22.jpg)
*Testbench contains stimulus to generate waveform such as input initial value and triggered period.*

![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_4_0](https://user-images.githubusercontent.com/62828746/205514407-834c9498-e069-4f39-98bb-5c7279cc45b5.jpg)
*After 50ns, sel is triggered, hence output will follow i0 value, y=1.*

![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_5_0](https://user-images.githubusercontent.com/62828746/205514403-96f1e1e3-26bb-436a-ada1-e415a13627ab.jpg)
*After 75ns, sel is triggered, hence output will follow i1 value, y=0.*

  </details>

<details open><summary> SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1 </summary>
 
### Lab - SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1
Related with theory part: [yosys (Yosys Open SYnthesis Suite) Based Synthesis Flow](https://github.com/teoh5128/intel-sd-training/edit/main/readme.md#yosys-yosys-open-synthesis-suite-based-synthesis-flow)

#### Steps:
> 1. Invoke synthesizer tools, yosys
>> *yosys*
> 2. Read the library
>> *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 3. Read the design. there should no error and will see "successfully finished verilog frontend" printed.
>> *read_verilog good_mux.v*
> 4. Link to the module name that want to be synthesized.
>> *synth -top good_mux*
> 5. Generate netlist, "abc" is the command which will convert rtl file into gate specified in the library "sky130_fd_sc_hd__tt_025C_1v80.lib".
>> *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 6. To see graphical version of the logic it does realized.
>> *show*

#### Result:
![SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1_result_1_0](https://user-images.githubusercontent.com/62828746/205514365-a1c5b714-5856-4f31-8220-0ede601699a9.jpg)
*Total inputs, library version used and total outputs shown in graphic should be the same with the ABC results.*
  </details>
 
<details open><summary> SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part2 </summary>
 
### Lab - SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part2

#### Steps:
> 1. Load verilog file and review it togther with graphical version of the logic.
>> *!vim good_mux_netlist.v*

#### Result:
![SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1_result_1_0_0](https://user-images.githubusercontent.com/62828746/205514500-9fedde6a-dd2c-4a7a-b86a-094072f3f2a5.jpg)
*mux2_1 is a multiplexer that will switch two input lines to a single common output line.*
     
  </details>

<details open><summary> SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part3 </summary>
 
### Lab - SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part3

#### Steps:
> 1. To write out synthesized netlist
>> *write_verilog good_mux_netlist.v*
> 2. To write out synthesized netlist in more simplified way.
>> *write_verilog -noattr good_mux_netlist.v*

#### Result:
![SKY130RTL D1SK4 L3 Lab3 Yosys 1 good mux Part3_result_0_0](https://user-images.githubusercontent.com/62828746/205514343-4116c058-f43d-449d-8772-dda8f0572d92.jpg)
*With no attribute switch, a more simplified netlist (without cell instantiation) will be generated.*
    
  </details>


## Day 2
## Theory - Timing libs(QTMs/ETMs), hierarchical vs flat synthesis and efficient flop coding styles

<details><summary> Cell Library Characterization </summary>
  
## **Cell Library Characterization**
* Cell library characterization important for moedeling standard cells in library.
* Models suitable for each chip implementations flows are different due to variations.
* Standard cell characterization used for collection cell's information such as leakage power, area, pins and timing.
* Synthesis tools need to know cell logic function, load, speed of cell under variation, power consumed, area and etc to synthesize behavioral description for standard cells.
* Even variation exist will effect cell's performance, but we need to make Silicon die works well in every corner.

  </details>

<details><summary> PVT </summary>
 
## **PVT**
* Cells behavior strongly depends on factors such as PVT, input signals and output load.
* To make fabricated chips working in all possible condition, stimulate it at different corners of process, voltage and temperature.
* While looking at best and worst PVT conditions allows us to predict lower and upper limitation of cell bahvior which are important to ensure the overall functionality of the design.


P (Process)                                      | V (Voltage)                                    | T (Temperature)
---------------------------------------------    | ---------------------------------------------  | --------------------------------------------- 
Different task or die area (center/boundary) has different process variation during fabrication | IR drop or supply noise might cause voltage variation. Even supplied voltage might not be stable all the time |  Density of transistor is inconsistent throughout the chip and resulting in power dissipation and temperature variation across the chip

  </details>

 
<details><summary> Hierachical and Flat Synthesis </summary>
  
## **Hierachical and Flat Synthesis**

Content   | Hierachical Synthesis | Flat Synthesis
---| --------------------  | -------------------- 
Definitions | Contains more than one module inside entire design. Each modules has interdependencies and have signals travelling between modules. | Contains only one module for entire design. It's a set of flat schematics and has no module interdependencies.
Pros | Sub-modules pins are accessible, it's easier to track path during functional debugging and timing analysis.  | Synthesis tool can optimize the circuit for better speed, area and power. 
Cons | Might cause issues when synthesize large design with massive sub-modules. | Debugging capabilities are limited.
Prefered | Prefered for human read-ability and debug purposes | Prefered when design has massive sub_modules, can synthezie one of it and stitch each netlist into top-level netlist.

  </details>

<details><summary> Glitch </summary>

## **Glitch**
* For combinational logic, propagation delay will cause output glitch.
* **Glitch** is unwanted and must be fixed.

![Glitch](https://user-images.githubusercontent.com/62828746/206111766-51f85c9d-62fd-4a7e-a331-9750b338ed2e.jpg)

  </details>

<details><summary> DFF </summary>
  
## **DFF**
* To fix glitch we need an element to store value periodically.
* **D Flip-flop** - acts as an electronic memory component since the output remains constant unless deliberately changed by altering the state of the D input at the given edge of clock.

![glitch combi](https://user-images.githubusercontent.com/62828746/206115287-75f6b5b8-5554-4464-9063-b0a9d8635d4c.jpg)
* Combinational circuit for sure will have output glitch due to logic gate propagational delay.
* Continous combitional circuit will even cause output continously has glitchy output and never settle down.

![stable combi](https://user-images.githubusercontent.com/62828746/206115291-cb106a81-7ce0-43f9-ab94-e0edf2e222b8.jpg)
* To avoid that, insert DFF for each combinational circuit.
* DFF shielded from D through clock, which means Q will only change whenever clk edge rise/fall and will not effcted by D.
* Even input is glitch, output of DFF will become stable and feed stable signal to next combinational circuit.


  </details>

<details><summary> Different type of flop and function </summary>
  
## **Different type of flop and function**
* Initial state of flip-flop is importtant to avoid next combinational logic grab and evaluate flip-flop value that are not yet initialized.
* Initialze of flip flop included set, reset, synchronous and asynchronous.

![asyn_dff](https://user-images.githubusercontent.com/62828746/206149008-ab6e106a-de71-4be7-a552-d327920d37b9.jpg)
* In **asynchronous reset**, the Flip Flop will not wait for the clock and sets the output right at the edge of the reset.
* Fast implmentation cause no need to wait for clock signal to be applied.

![sync_dff](https://user-images.githubusercontent.com/62828746/206149022-31e6c2b9-a46c-444c-89e1-e0c60325e8f3.jpg)
* In **synchronous Reset**, the Flip Flop waits for the next edge of the clock ( rising or falling), before applying the Reset of Data.
* If duration of rising edge of clock and reset edge is too short might causing metastability issues.
* DFF must have certain minimum time between reset edge and clock edge, which is reset recovery time. 

![asyn_sync_dff](https://user-images.githubusercontent.com/62828746/206149017-a90fa6d4-1492-46da-9d63-c432c00a727e.jpg)
* If both **aysnchronous reset and synchronous** reset are used, asynchronous reset has higher priority compared to synchronous reset.

  </details>
  

## Lab Topic - SKY130RTL D2SK1 - Introduction to timing .libs

<details open><summary> SKY130RTL D2SK1 L1 Lab4 Introduction to dot Lib part1 </summary>
  
### Lab - SKY130RTL D2SK1 L1 Lab4 Introduction to dot Lib part1

#### Steps:
> 1. Open library file and review what contains in .lib file. [*DO NOT EDIT .LIB FILE, ONLY READ]
>> *vim /lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 2. Tips to switch off syntax for more pleasant review experience. 
>> *:syn off*
> 3. Look into the information contains in .lib, such as library name, power, voltage and temperature of cell.

#### Result:

![SKY130RTL D2SK1 L1 Lab4 Introduction to dot Lib part1_result](https://user-images.githubusercontent.com/62828746/205701093-f65384e7-3f54-4ad0-b684-2d55bac72677.jpg)
*PVT information in .lib are important variations for a design to work.*

  </details>
 

<details open><summary> SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2 </summary>
  
### Lab - SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2

#### Steps:
> 1. There are various type of standard cells inside .lib file, we will see each cell features inside .lib.
>> *refer to resut_1.jpg*
> 2. To understand cell functionality, can review its equivalent verilog model.
>> *:sp ../my_lib/verilog_model/*
> 3. Delay and leakage power for all possible combitional inputs for a cell are also listed inside .lib.
>> *refer to result_2.jpg*

#### Result:
![SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2_0a](https://user-images.githubusercontent.com/62828746/205701105-9d011958-99a0-49aa-9948-bd993caf6c6d.jpg)

*resut_1*

![SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2_1a](https://user-images.githubusercontent.com/62828746/205701108-a5bf7783-2d6f-49f1-9864-7d5cbe98d6df.jpg)

*resut_2*

![SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2_2a](https://user-images.githubusercontent.com/62828746/205701110-67e8a486-fd22-4e4b-9c24-6cb99faf31f3.jpg)

  </details>
  
<details open><summary> SKY130RTL D2SK1 L3 Lab4 Introduction to dot Lib part3 </summary>
  
### Lab - SKY130RTL D2SK1 L3 Lab4 Introduction to dot Lib part3
Related with theory part: [How Capacitance Effect Circuit's Speed](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#how-capacitance-effect-circuits-speed)

#### Steps:
> 1. Same cell type with different flavour will have different value in leakage power and area.
>> *:vsp*

#### Result:
![SKY130RTL D2SK1 L3 Lab4 Introduction to dot Lib part3_result_0a](https://user-images.githubusercontent.com/62828746/205701114-6f4f12b9-da8b-4143-b160-bcab608269d4.jpg)
*Faster cell with higher power has larger transistor, and will trade off with area consumed.*

  </details>
  
## Lab Topic - SKY130RTL D2SK2 - Hierarchical vs Flat Synthesis

<details open><summary> SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1 </summary>
    
### Lab - SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1

#### Steps:
> 1.Take multiple_modules as example, may load multiple_modules.v file and review it's sub-module functionality.
>> *vim multiple_modules.v*
> 2. Run synthesis to see how top modules and sub-modules synthesis result make differences.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog multiple_modules.v*
>> * *synth -top multiple_modules*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show multiple_modules*
>> * *write_verilog -noattr multiple_modules_hier.v*
> 3. Open and review generated netlist.
>> * *!vim multiple_modules_hier.v*
>> * *refer to result_2.jpg*

#### Result:
![SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1_result](https://user-images.githubusercontent.com/62828746/205941637-f46452bf-1c33-4c2a-9520-ec809fe51dd7.jpg)

![SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1_result_0](https://user-images.githubusercontent.com/62828746/205940021-e3550d9f-5d2f-4093-abc5-bbf904e1ecc0.jpg)

*Instead of AND and OR logic gate, we see U1 and U2, this is the hierachical design*

![SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1_result_1](https://user-images.githubusercontent.com/62828746/205940035-aca88f85-7eeb-4b22-adb1-09a46b43664d.jpg)

*result_2.jpg*

  </details>
  
<details open><summary> SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2 </summary>
  
### Lab - SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2

#### Steps:
> 1. Use command to write out flat netlist.
>> * *flatten*
>> * *write_verilog -noattr multiple_modules_flat.v*
> 2. Open and review generated netlist.
>> *!vim multiple_modules_flat.v*
> 3. Instead of multiple_modules, now try to do a sub-module level synthesis.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
>> * *read_verilog multiple_modules.v*
>> * *synth -top sub_module1*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:

![SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2_0](https://user-images.githubusercontent.com/62828746/205951977-f5421835-b178-46d7-9fc5-6129d4cb07f0.jpg)

![SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2_1](https://user-images.githubusercontent.com/62828746/205951986-657e5cee-aefa-4a79-9738-0303eba015ea.jpg)

![SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2_2](https://user-images.githubusercontent.com/62828746/205951994-b0a98ae0-f52c-4d5e-baef-206a4ab6cb30.jpg)

  </details>

## Lab Topic - SKY130RTL D2SK3 - Various Flop Coding Styles and optimization
  
<details open><summary> SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1 </summary>
  
### Lab - SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1

#### Steps:
> 1. Take asynchronous reset flip flop as example. Run simulation by apply RTL Design (dff_asyncres.v) and testbench (tb_dff_asyncres.v) as inputs.
>> * *iverilog dff_asyncres.v tb_dff_asyncres.v*
>> * *./a.out*
>>  *gtkwave tb_dff_asyncres.vcd*
> 2. Take synchronous reset flip flop as example. Run simulation by apply RTL Design (dff_syncres.v) and testbench (tb_dff_syncres.v) as inputs.
>> * *iverilog dff_syncres.v tb_dff_syncres.v
>> * *./a.out*
>> * *gtkwave tb_dff_syncres.vcd*

#### Result:
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_0](https://user-images.githubusercontent.com/62828746/206079681-127eb22e-f0fd-4a01-8ba5-6c99e106ab35.jpg)
*asynchronous reset flip flop waveform*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_1](https://user-images.githubusercontent.com/62828746/206079656-679d86f4-36e9-49f9-9add-94d2acdd0d80.jpg)
*asynchronous reset flip flop waveform*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_2](https://user-images.githubusercontent.com/62828746/206079660-462b73df-ad21-476a-a32b-8c75b3a49aed.jpg)
*synchronous reset flip flop waveform*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_3](https://user-images.githubusercontent.com/62828746/206079666-3ba2f68f-6a04-430d-aa37-8d51ac88a8aa.jpg)
*synchronous reset flip flop waveform*

  </details>
  
<details open><summary> SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2 </summary>
  
### Lab - SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2

#### Steps:
> 1. We have done simulation of flip flop in part1, now run synthesis for asynchronous_reset flip flop and see the netlist.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_asyncres.v*
>> * *synth -top dff_asyncres*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> this will make it only looking for flip flop standard cell in .lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

> 2. Read asynchronous_set flip flop netlist.
>> * *read_verilog dff_async_set.v*
>> * *synth -top dff_async_set*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

> 3. Read synchronous_reset flip flop netlist.
>> * *read_verilog dff_syncres.v*
>> * *synth -top dff_syncres*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2_0](https://user-images.githubusercontent.com/62828746/206079667-6627f537-235f-4f98-98dd-49e506b7e50a.jpg)
*Command dfflibmap used will only looking for flip flop standard cell in .lib file.*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2_1](https://user-images.githubusercontent.com/62828746/206079670-39d2ba3f-005f-4d7a-b9a6-0e71333b4d8c.jpg)
*Differences of asynchronous_reset with asynchronous_set*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2_2](https://user-images.githubusercontent.com/62828746/206079674-bc8452b9-4bfa-4194-a0ed-22dc56f95deb.jpg)
*Synchronous_reset flip flop grapgical block*

  </details>
  
## Lab Topic - SKY130RTL D2SK3 - Various Flop Coding Styles and optimization
<details><summary> SKY130RTL D2SK3 L5 Interesting optimisations part1 </summary>
  
### Lab - SKY130RTL D2SK3 L5 Interesting optimisations part1

#### Steps:
1. Run multiplexer_2 synthesis and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib* 
>> * *read_verilog mult_2.v*
>> * *synth -top dff_asyncres*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
>> * *write_verilog -noattr mul2_net.v*

#### Result:
![SKY130RTL D2SK3 L5 Interesting optimisations part1_0](https://user-images.githubusercontent.com/62828746/206079676-189935c3-e858-4d57-8684-16880b3f6a6b.jpg)

  </details>
  
<details open><summary>  SKY130RTL D2SK3 L5 Interesting optimisations part2 </summary>
  
### Lab - SKY130RTL D2SK3 L5 Interesting optimisations part2

#### Steps:
1. Run multiplexer_8 synthesis and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog mult_8.v*
>> * *synth -top mult8*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
>> * *write_verilog -noattr mul8_net.v*

#### Result:
![SKY130RTL D2SK3 L5 Interesting optimisations part1_1](https://user-images.githubusercontent.com/62828746/206079678-c3a23b3d-59c1-4b40-bb79-010964f8ae09.jpg)

  </details>

## Day 3
## Theory - Combinational and sequential optmizations

<details><summary> Optimisation of Synthesis Tools </summary>
  
## **Optimisation of Synthesis Tools**
* When device library cells are instantiated, **synthesis tools do not optimize them by default**. 
* Even when instructed to optimize the device library cells, synthesis tools generally cannot perform the same level of optimization as with the RTL. 
* Therefore, synthesis tools typically **only perform optimizations on the paths to and from these cells** but not through the cells.
* Synthesis optmization helps to reduce circuit delay by reduce gate count without effecting original logic to meet timing constraints.
* Synthesis tool perform optimization by minimize cost function.
* **Cost function** comes in various flavour depend on EDA tool vendor.
* Two of the important cost function to minimize: time related and delay cost. 
  </details>

<details><summary> Constant propagation </summary>
  
## **Constant propagation**
* Constant propagation - a process of substituting the constant value of variables in the expression.
* It is one of the local code optimization technique for compiler.
  </details>

<details><summary> Combinational vs Sequential optimization </summary>
  
## **Combinational vs Sequential optimization**
Key          | Combinational Circuit                                   | Sequential Circuit
-------------    | ---------------------------------------------  | ------------------
Definition | Combinational Circuit is the type of circuit in which output is independent of time and only relies on the current input. |Sequential circuit is the type of circuit where output relies on both current input and also previous output. 
Optimization | constant propagation is Boolean algebra. | constant propagation is Boolean algebra + timing.
  </details>

<details><summary> Boolean Logic Optimisation </summary>
  
## **Boolean Logic Optimisation**
* **logic optimisation** improves simulation efficiency by simplyfy a complex boolean expression to simpler one which would ultimately produce same result.
* **Boolean algebra** refers to symbolic manipulation of expressions made up of boolean variables and boolean operators.
* **Axioms of Boolean algebra** : identity, commutative, distributive, and associative

<img width="615" alt="Boolean algebra" src="https://user-images.githubusercontent.com/62828746/206801948-d9fdeb1b-aafc-47d1-aeeb-e4574b9eba88.png">

*Axioms of Boolean algebra [reference from: 7.1   Boolean Logic](https://introcs.cs.princeton.edu/java/71boolean/)*

<img width="516" alt="identities" src="https://user-images.githubusercontent.com/62828746/206801941-30dd7c69-dcfc-457a-8eb3-8d89be6ee89b.png">

*Laws of Boolean Algebra [reference from: 7.1   Boolean Logic](https://introcs.cs.princeton.edu/java/71boolean/)*
  </details>

<details><summary> Boundary Optimisation </summary>
  
## **Boundary Optimisation**
*  Boundary optimisation is the optimisation undergo across boundary. 
*  Boundary optimisation including conatant optimization across hierarhies, remove unloaded logic connected, collapse equal and opposite pins, rewiring of equivalent signals across hierarchy and etc.
*  For example: Boundary optimisation will remove unused buffers that are inserted for allowing signal out of the module, then it will replace an inverters to see is it good enough for signal going out.
  </details>

## Lab Topic - SKY130RTL D3SK2 - Combinational logic optimizations

<details open><summary> SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1 </summary>
  
### Lab - SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1

#### Steps:
> 1. Review optimization verilog file (opt_check.v and opt_check2.v).
>> *ls *opt_check**
>> *gvim opt_check.v*
>> *gvim opt_check2.v*
> 2. Run synthesis for opt_check.v and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog opt_check.v*
>> * *synth -top opt_check*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
> 3. Run synthesis for opt_check2.v and review it's netlist and grpahical block.
>> * *read_verilog opt_check2.v*
>> * *synth -top opt_check2*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1_0](https://user-images.githubusercontent.com/62828746/206799590-79949c0b-a29b-4ed3-aea5-67b5adeae60c.jpg)

*Review opt_check.v and opt_check2.v file.*
![SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1_1](https://user-images.githubusercontent.com/62828746/206799599-febe29b7-b91a-4ca9-8b0c-a1da420e26c9.jpg)

*An AND gate was inferred in the circuit as expected*
![SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1_2](https://user-images.githubusercontent.com/62828746/206799603-7f31f792-c06a-4538-b4f1-b9e7f35b89b4.jpg)

*An OR gate was inferred in the circuit as expected*

  </details>

<details open><summary> SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations part2 </summary>
  
### Lab - SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations part2

#### Steps:
> 1. Review third optimization verliog file (opt_check3.v).
> 2. Run synthesis for opt_check3.v and review it's netlist and grpahical block.
>> * *read_verilog opt_check3.v*
>> * *synth -top opt_check3*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations part2_0](https://user-images.githubusercontent.com/62828746/206799763-a6f440ad-869e-48a4-9b01-ff01c2ea4111.jpg)
*Review opt_check3.v file.*
![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations part2_1](https://user-images.githubusercontent.com/62828746/206799757-90d69bc5-476a-40ac-8832-f0ccc9cfb5e2.jpg)
*An 3-input AND gate was inferred in the circuit as expected*

  </details>
  

<details open><summary> SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise) </summary>
  
### Lab - SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)

#### Steps:
> 1. Review the two multiple_module verliog file (multiple_module*.v and multiple_module_opt2.v).
>> * *gvim multiple_module_opt.v -o multiple_module_opt2.v*
> 2. Run synthesis for multiple_module_opt.v and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog multiple_module_opt.v*
>> * *synth -top multiple_module_opt*
>> * *flatten -> to get flat schematic*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
> 3. Run synthesis for multiple_module_opt2.v and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog multiple_module_opt2.v*
>> * *synth -top multiple_module_opt2*
>> * *flatten->to get flat schematic*
>> * *opt_clean -purge->command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_0](https://user-images.githubusercontent.com/62828746/206799866-4a387398-cdba-4283-916d-956567df71f0.jpg)

*Review multiple_module verliog file(multiple_module_opt.v and multiple_module_opt2.v)*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_1](https://user-images.githubusercontent.com/62828746/206799870-a47c7051-7b14-4041-a2c6-de493194b7a2.jpg)

*Synthesis result of multiple_module_opt.v*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_2](https://user-images.githubusercontent.com/62828746/206799872-3bb846d1-90c1-4ce2-966b-d51ab1131b7c.jpg)

*After flatten the hierachical and optimization, 3-input AND-OR gate is used for output Y.*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_3](https://user-images.githubusercontent.com/62828746/206799873-a6d92257-7ea8-46cf-8258-9ee41870dfa0.jpg)

*Synthesis result of multiple_module_opt2.v*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_4](https://user-images.githubusercontent.com/62828746/206799874-21d36b85-c6d3-4561-a6f3-9b9b42651534.jpg)

*After flatten the hierachical and optimization, output Y is direct assigned to value 0*


  </details>
  
## Lab Topic - SKY130RTL D3SK3 - Sequential logic optimizations

<details open><summary> SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1 </summary>
  
### Lab - SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1

#### Steps:
> 1. Review the dff file that will be the example for sequential logic optimization.
>> *gvim dff_const1.v -o dff_const2.v*
> 2. Run simulation by apply RTL Design (dff_const1.v) and testbench (tb_dff_const1.v) as inputs.
>> *iverilog dff_const1.v tb_dff_const1.v*
>> *./a.out*
>> *gtkwave tb_dff_const1.vcd*
> 3. Run simulation by apply RTL Design (dff_const2.v) and testbench (tb_dff_const2.v) as inputs.
>> *iverilog dff_const2.v tb_dff_const2.v*
>> *./a.out*
>> *gtkwave tb_dff_const2.vcd*
> 4. Now, run synthesis for dff_const1 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const1.v*
>> * *synth -top dff_const1*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> tell synthesis tool the sequential circuit is mainly for dff latches and only pick flip flop standard cell in .lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_0](https://user-images.githubusercontent.com/62828746/206800029-a2a33821-33fb-405b-b6a0-46c461b81a47.jpg)
*Review dff verilog file.*
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_1](https://user-images.githubusercontent.com/62828746/206800034-f72f23b8-16eb-4922-b9ad-ca7cf55e5068.jpg)
*Resulted waveform of tb_dff_const1.vcd*
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_2](https://user-images.githubusercontent.com/62828746/206800036-48810996-470b-4ee5-b718-1a7044c4d45d.jpg)
*Resulted waveform of tb_dff_const2.vcd*
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_3](https://user-images.githubusercontent.com/62828746/206800039-17e98ebf-6270-4ada-b961-64c6afa67456.jpg)
*Resulted graphic design is as expected.*

  </details>

<details open><summary> SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2 </summary>
  
### Lab - SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2
#### Steps:
> 1. Now, run synthesis for dff_const2 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const2.v*
>> * *synth -top dff_const2*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> tell synthesis tool the sequential circuit is mainly for dff latches and only pick flip flop standard cell in .lib*
> 2. Review the dff_const3 verilog file that will be the next example for sequential logic optimization.
> *gvim dff_const3.v*

#### Result:
![SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2_0](https://user-images.githubusercontent.com/62828746/206800108-9b7dff16-df81-4d23-a506-649899d2830c.jpg)
*D flip flop are optmized in the constant propagation optimization steps.*
![SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2_1](https://user-images.githubusercontent.com/62828746/206800112-3efadaeb-489a-4c22-8f54-c8d227ee6007.jpg)
*Review dff_const3.v file.*

  </details>
  

<details open><summary> SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 </summary>

### Lab -SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3
#### Steps:
> 1. Run simulation by apply RTL Design (dff_const3.v) and testbench (tb_dff_const3.v) as inputs.
> >> *iverilog dff_const3.v tb_dff_const3.v*
>> *./a.out*
>> *gtkwave tb_dff_const3.vcd*
> 2. Now, run synthesis for dff_const3 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const3.v*
>> * *synth -top dff_const3*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> tell synthesis tool the sequential circuit is mainly for dff latches and only pick flip flop standard cell in .lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3_0](https://user-images.githubusercontent.com/62828746/206800170-a00e923d-05a9-4989-966d-f57417518e60.jpg)
*Resulted waveform of tb_dff_const3.vcd as expected.*
![SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3_1](https://user-images.githubusercontent.com/62828746/206800178-fcc2258f-c250-49f7-b411-62ec74abc160.jpg)
*There are 2 flip flop inferring in the circuit as expected.*
![SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3_2](https://user-images.githubusercontent.com/62828746/206800180-f9e39367-51a2-4fb0-a353-8922b87333fe.jpg)
*Resulted graphic design is as expected.*

  </details>

<details open><summary> SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise) </summary>

### Lab -SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)
> 1. Review the dff file.
>> gvim dff_const4.v 
> 2. Run simulation by apply RTL Design (dff_const4.v) and testbench (tb_dff_const4.v) as inputs.
> >> *iverilog dff_const4.v tb_dff_const4.v*
>> *./a.out*
>> *gtkwave tb_dff_const4.vcd*
> 3. Now, run synthesis for dff_const4 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const4.v*
>> * *synth -top dff_const4*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

> 1. Review the dff file.
>> gvim dff_const4.v 
> 2. Run simulation by apply RTL Design (dff_const5.v) and testbench (tb_dff_const5.v) as inputs.
> >> *iverilog dff_const5.v tb_dff_const5.v*
>> *./a.out*
>> *gtkwave tb_dff_const5.vcd*
> 3. Now, run synthesis for dff_const3 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const5.v*
>> * *synth -top dff_const5*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_0](https://user-images.githubusercontent.com/62828746/206800243-62f5e767-a4d0-416e-8712-704f4f7a7cff.jpg)
*Review dff_const4.v file.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_1](https://user-images.githubusercontent.com/62828746/206800246-e479b304-4b9c-4c1b-b298-5471625d0349.jpg)
*Resulted waveform of tb_dff_const4.vcd as expected, q1 and q value is constant.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_2](https://user-images.githubusercontent.com/62828746/206800251-1744bef1-c422-4fc4-8ca4-a0be846869b2.jpg)
*Resulted graphic design is as expected, flop,clk and reset are optimized.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_3](https://user-images.githubusercontent.com/62828746/206800253-1ad61fa2-5928-40ff-8665-93fd63e37e5b.jpg)
*Review dff_const5.v file.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_4](https://user-images.githubusercontent.com/62828746/206800256-990bf112-bc6f-49f3-a109-f574bb9384ec.jpg)
*Resulted waveform of tb_dff_const5.vcd as expected, q1 and q value is not constant.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_5](https://user-images.githubusercontent.com/62828746/206800261-6f33b73a-9113-4078-bd03-ad867d14e23e.jpg)
*Resulted graphic design is as expected, flop can't be optimized.*

  </details>

## Lab Topic - SKY130RTL D3SK4 - Sequential optimzations for unused outputs

<details open><summary> SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1 </summary>
  
### Lab - SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1

#### Steps:
1. Review the counter_opt verilog and take it as example for optimisation of unused outputs in circuit.
>> * *gvim counter_opt.v*
> 2. Now, run synthesis and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog counter_opt.v*
>> * *synth -top counter_opt*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1_0](https://user-images.githubusercontent.com/62828746/206800384-09212387-6ff5-48cd-808a-60629c718502.jpg)
*Review 3-bit counter, counter_opt.v file.*
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1_2](https://user-images.githubusercontent.com/62828746/206800390-9ac3772b-da06-4ed1-b972-89673ced638a.jpg)
*Only one DFF used in circuit cause unused flop are optimized.*

  </details>
  
<details open><summary> SKY130RTL D3SK4 L2 Seq optimisation unused outputs part2 </summary>
  
### Lab - SKY130RTL D3SK4 L2 Seq optimisation unused outputs part2

#### Steps:
1. Modidy counter_opt verilog and take it as second example for optimisation of unused outputs in circuit.
>> * *cp counter_opt.v counter_opt2.v*
>> * *gvim counter_opt2.v*
>> * *assign q = count[0] -> q = [count[2:0] == 3'b100]*
> 2. Now, run synthesis and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog counter_opt2.v*
>> * *synth -top counter_opt*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_3](https://user-images.githubusercontent.com/62828746/206800449-e1829e70-88e6-44c1-bad0-d2947e56d408.jpg)
*Edit counter_opt2 verilog file and assigned q to counter[2] when bit 3'b100*
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_2](https://user-images.githubusercontent.com/62828746/206800447-c5125ee0-73ea-4b28-8ae2-9f15590eac50.jpg)
*There are 3 flops are inferred in the circuit as expected.*
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_1](https://user-images.githubusercontent.com/62828746/206800444-feda61e3-1b53-4474-9181-1d36abc56d6f.jpg)
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_0](https://user-images.githubusercontent.com/62828746/206800450-15bbd3b8-305a-4536-a644-d16c0c067b26.jpg)
*Highlighted path is the path of input to output path in summary.*

  </details>

## Day 4
## Theory - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch

<details open><summary> Gate Level Simulation (GLS) </summary>
  
## **Gate Level Simulation (GLS):**
* **GLS** process also used to verify design's functionality but it includes standard cell/gate propagation delay into consideration in the verification process. And delays will change according to library used for synthesis.
* While **RTL simulation** process doesn't include standard cell/gate propagation delay into consideration while verify design's functionality.
* GLS used to verify dynamic circuit behaviour which can't be verified accurately by static methods.

  </details>

<details open><summary> GLS using Iverilog Flow </summary>
  
## **GLS using Iverilog Flow:**
![GLS using Iverilog Flow](https://user-images.githubusercontent.com/62828746/206912462-bf416918-dbad-49f7-b07b-232ffbe067a4.jpg)
* It's similar with the simulation flow that using RTL code as DUT(design under test), just that now using **netlist as DUT**.
* Plus we have **gate-level verilog model** as inputs to simulator to define standard cell inside netlist to the tool.

  </details>

<details open><summary> RTL Simulation vs Gate-level Simulation(GLS) </summary>
  
## **RTL Simulation vs Gate-level Simulation(GLS)**
Key   | RTL Simulation | Gate-level Simulation(GLS)
---| --------------------  | -------------------- 
**Function** | Simulates the code directly, it's a zero delay environment and intends only for functional check. | Simulate code using real timing, can be zero delay (functional only) but mostly with standard cell delays.
**Process** | Pre-synthesis | Post-synthesis
**Process Inputs** | RTL code (with functionality without timing information) | Compiled netlist (with/without timing information)
**Process Speed** | Fast (more simple since state of DUT updated once per clock cycle) | Very slow (more complex and event to calculate due to actual timing delays from layout)

  </details>
  
<details open><summary> Gate Level Verilog Model </summary>

## **Gate Level Verilog Model:**
* **Gate-level modeling** involves gates and has a one to one relationship between a hardware schematic and the Verilog code.
* **Gate level verilog model** is used to define gate/standard cell inside the netlist.
+ **Type of gate level verilog model:**
  * **Timing aware:** ensure both design functionality and timing.
  * **Functional:** only ensure design functionality.

![Gate Level Verilog Model](https://user-images.githubusercontent.com/62828746/206912030-dc67e1f1-6d2b-4876-b097-8b16eb2f2c93.jpg)

  </details>

<details open><summary> Sensitivity List </summary>
  
## **Sensitivity List**
* Simulators are event based. This means that simulators operate by taking events one at a time and propagating them through design until reached steady condition.

![Missing sensitivity list](https://user-images.githubusercontent.com/62828746/207013728-bb850dff-ceef-41f9-b5f6-e697ba1899f0.jpg)

* **Events:** Any transitions of input signals or always statement.
* **Sensitivity lists:** Used to indicate which events may trigger the process.
+ **Simulator:** 
  * will observe the sensitivity list. 
  * If an input of a procedure or always statement is not in the sensitivity list, a transition of that signal will not trigger the procedure, and no new output is produced.
+ **Synthesizer:**
  * will ignore the sensitivity list.
  * A new output is calculated according to the code of the procedure or always statement. 
  * May warn for an incomplete sensitivity list.
* Missing items in sensitivity list cause or hide a design flaw and cause **synthesis-simulation mismatch**.
 
  </details>

 
<details open><summary> Blocking and Non-Blocking Statements in Verilog </summary>
  
 ## **Blocking and Non-Blocking Statements in Verilog:**

* **Blocking (=)** and **Non-blocking (<=)** assignments are provided to control the execution order within an always block.
* Coding styles (blocking and non-blocking assignment) in RTL code can cause mismatches between pre-synthesis (RTL Simulation) and post-synthesis (Gate-level Simulation) simulations. -> **Synthesis and simulation mismatch**

Blocking Assignments |  Non-Blocking Assignments
--------------------  | -------------------- 
Executes the statements in the order it is written | Executes all the RHS when always block is entered and assigns to LHS
Preserves logic flow, works better for combinational logic | Doesn't preserve logic flow, work better for sequential lofic
 
![BlockingAndNonBlockingStatementsInVerilog](https://user-images.githubusercontent.com/62828746/207052068-978ac909-5e02-42f7-8531-33c1cc1e7de7.jpg)

  </details>
  
## Lab Topic - SKY130RTL D4SK2 - Labs on GLS and Synthesis-Simulation Mismatch

<details open><summary> SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1 </summary>

### Lab - SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1

#### Steps:
> 1. Review the ternary operator mux file.
>> gvim ternary_operator_mux.v 
> 2. Run simulation by apply RTL Design (ternary_operator_mux.v) and testbench (tb_ternary_operator_mux.v) as inputs.
> >> *iverilog ternary_operator_mux.v tb_ternary_operator_mux.v*
>> *./a.out*
>> *gtkwave tb_ternary_operator_mux.vcd*
> 3. Now, run synthesis for ternary_operator_mux and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog ternary_operator_mux.v*
>> * *synth -top ternary_operator_mux*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr ternary_operator_mux.v*
>> * *show*
4. Now run the GLS simulation for ternary operator mux using generated mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux.v tb_ternary_operator_mux.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_ternary_operator_mux.vcd*

#### Result:

![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_0](https://user-images.githubusercontent.com/62828746/207109722-5a504299-1f03-48a1-9c28-899f11e64afc.jpg)
*Review ternary operator mux verilog file.*
![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_1](https://user-images.githubusercontent.com/62828746/207109729-f81fb4e3-26d0-4b4a-a058-2a60e981fdda.jpg)
*Resulted waveform of ternary operator mux is as expected.*
![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_2](https://user-images.githubusercontent.com/62828746/207109713-4993db5a-9558-44df-98f5-6e89c790d6aa.jpg)
*Resulted circuit is as expected, infered with two cross one mux standard cell.*
![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_3](https://user-images.githubusercontent.com/62828746/207109719-7a84573f-9f2a-4ec7-8ccd-33ba2299f9d0.jpg)
*Resulted waveform as expected, GlS output follow mux behaviour.*
  
  </details>
  
<details open><summary> SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2 </summary>
  
### Lab - SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2

#### Steps:
> 1. Review the bad mux file.
>> gvim bad_mux.v 
> 2. Run simulation by apply RTL Design (bad_mux.v) and testbench (tb_bad_mux.v) as inputs.
> >> *iverilog bad_mux.v tb_bad_mux.v*
>> *./a.out*
>> *gtkwave tb_bad.vcd*
> 3. Now, run synthesis for bad_mux and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog bad_mux.v*
>> * *synth -top bad_mux*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr bad_mux_net.v*
>> * *show*
4. Now run the GLS simulation for bad mux using generated bad mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v bad_mux.v tb_bad_mux_net.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_bad.vcd*

#### Result:
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_0](https://user-images.githubusercontent.com/62828746/207128208-7a8a738d-fd69-4d5e-886f-cd590e5648ca.jpg)
*Review bad mux verilog file.*
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_1](https://user-images.githubusercontent.com/62828746/207128215-6175d4ff-970a-4531-ac81-18e8024a6454.jpg)
*Resulted RTL simulation waveform showing flop behaviour instead of mux.*
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_2](https://user-images.githubusercontent.com/62828746/207128219-05d5ce3f-7d1f-4784-97dd-760b35edcdc2.jpg)
*Resulted gate-level simulation(GLS) waveform showing mux.*
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_3](https://user-images.githubusercontent.com/62828746/207128224-7dd4bc3d-f108-4268-b54a-c2a28fb1fd2e.jpg)
*Comparison of RTL simulation and GLS waveform.*

  </details>
  
<details open><summary> SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement part1 </summary>
  
### Lab - SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement part1

#### Steps:
> 1. Review the blocking_caveat file.
>> *gvim blocking_caveat.v*
> 2. Run simulation by apply RTL Design (blocking_caveat.v) and testbench (tb_blocking_caveat.v) as inputs.
> >> *iverilog blocking_caveat.v tb_blocking_caveat.v*
>> *./a.out*
>> *gtkwave tb_blocking_caveat.vcd*
> 3. Now, run synthesis for blocking_caveat and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog blocking_caveat.v*
>> * *synth -top blocking_caveat*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr blocking_caveat_net.v*
>> * *show*
4. Now run the GLS simulation for bad mux using generated bad mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_blocking_caveat.vcd*


#### Result:
![SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement part1_0](https://user-images.githubusercontent.com/62828746/207128418-8408fbf0-aec3-49fd-ae66-fdc33c145cc1.jpg)
*Review blocking_caveat verilog file.*
![SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement part1_1](https://user-images.githubusercontent.com/62828746/207128420-a6e8c67e-d94a-4c7e-af2f-c52b385afc01.jpg)
*Resulted RTL simulation waveform shows that output depends on previous a value.*

  </details>

<details open><summary> SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2 </summary>

### Lab - SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2

#### Steps:
> 1. Now, run synthesis for blocking_caveat and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog blocking_caveat.v*
>> * *synth -top blocking_caveat*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr blocking_caveat_net.v*
>> * *show*
2. Now run the GLS simulation for bad mux using generated bad mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_blocking_caveat.vcd*


#### Result:
![SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2_0](https://user-images.githubusercontent.com/62828746/207128424-689b8d9c-8a16-41d4-b229-89e069235a1b.jpg)
*Resulted circuit is as expected, only include OR2AND Gate and no latch.*
![SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2_1](https://user-images.githubusercontent.com/62828746/207128427-cdec553e-5854-4e2c-a61c-4df7662fa1ae.jpg)
*Resulted gate-level simulation waveform shows expected result.*
![SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2_2](https://user-images.githubusercontent.com/62828746/207128431-44c8e7b2-01d9-4fdd-95ab-ab53476a7589.jpg)
*Comparison of RTL simulation and GLS waveform.*

  </details>


## Day 5
## Theory - DFT (Design for Testability)
<details><summary> DFT (Design for Testability) </summary>

## **What is testability in VLSI means**
* Testability is the property of a circuit that makes it easy to test. If a design is well-controllable and well-observable, then it is easily testable.
* **Controllability** - ability to set a specific states or logic values (0 or 1) at each circuit nodes.
* **Observability** - ability to obeserve the states or logic values at any circuit nodes.

## **What is DFT (Design for Testability)**
* DFT is an innovative design technique which facilitates a design to become testable after production.
* DFT make testing a chip cost-effective by adding an extra logic/circuitry to the existing design.
* These extra design improve the observability and controability of internal nodes to increase testability of all logic in the design.
* Examples: addition of test points, parametric measurement devices, self-test diagnotics, test modes, and scan design.

## **Examples of circuit modifications or additions to make chip testable:**

Types | MBIST (Memory Built-In Self Test) | Scan Chains | Automates Test Pattern Generation (ATPG)
--------------------  | -------------------- | --------------------  | --------------------  |
Function | Running several algorithms and to verify memory functionality.It implements a finite state machine (FSM) to generate stimulus and analyze the response coming out of memories. | Inserted into designs to shift the test data into the chip and out of the chip. It was used by external automatic test equipment (ATE) to deliver test pattern data from its memory into the device. | It's the process of generating test patterns for a given fault model which will detect all possible fault conditions and find redundant circuit logic.   
Block diagram |![MBIST (Memory Built-In Self Test)](https://user-images.githubusercontent.com/62828746/207897281-cac40dd0-13d8-41a2-9dbc-9b510e47279f.jpg) | ![Scan Chains](https://user-images.githubusercontent.com/62828746/207914806-93cae819-50c7-4395-9a62-b1b266a26377.jpg) | ![Combinational Logic Testing](https://user-images.githubusercontent.com/62828746/207914814-c15beeda-166f-41e1-9048-663974c1efe1.jpg)
How it works | The MBIST controller provides control signals to the address and data generator. The memory, then, starts the BIST algorithms and provides the test output to the controller. The controller compares this output with the reference output and indicates if the MBIST has passed or failed.  | A multiplexer is added at the input of the flip-flop with one input of the multiplexer acting as the functional input D, while the other is Scan-In (SI). while scan-enable is used to control which input (D or SI) will propagate to the output. | To test an n input circuit is to generate all the possible 2N input signal combinations by means of say an N bit counter (controllability) and observe the outputs for checking (observability). But, is only practicable where N is relatively small.
Pros | * Allows robust testing of memories * Reduce in test cost and time * Design memories can be tested in parallel | Ensures that each circuit nodes becomes controllable and observable | * High fault coverage * Moderate area * Design automation
Cons | Increase in area |  * Extra I/O needed * Increse complexity and area  | * Large test data volume * Slow and long testing time
Used to test design | Macros/memory blocks | Flops | Cmbinational cirruit

## **Why do we need DFT**
* **DFT** makes testing easy at the post-production process.
+ DFT accomplishes two significant goals in the chip manufacturing process:
  * Control product quality by reject defective chips
  * Monitor and improve manufacturing process by identifying the probable defect location when testing various level.
+ 3 main levels of testing aftr chip being fabricated:
  * Chip-level, when chips are manufactured. Test overall product quality by ensure chip works smoothly.
  * Board-level, when chips are integrated on the boards/package. Test chips operationa life with temperature test.
  * System-level, when several boards are assembled together. To ensure that replaceable parts works smoothly.
*  Detect fault at earlier stage is important cause when move to higher levels, more components are integrated and it makes the fault detection and localization much more difficult and expensive.

**Pros** | **Cons**
---  | ---
Reduces tester complexity | Adds complication to the design flow.
Reduces tester time | Increase power, area, timing and package pins.
Reduces the chances of going into loss due to faulty devices | Design time increases

## **When DFT is included**
* DFT architecture is created at the beginning of design flow. Increase testability by adding extra blocks.
* DFT insertion occurs at synthesis stage during ASIC design flow. -> **Pre-fabrication**
* Dies are tested on wafer or re-tested with APTG patterns after passed wafer test. -> **Post fabrication**

## **Controllability in term of DFT**
* A point is said to be controllable if both ‘0’ and ‘1’ can be propagated through scan patterns.
* **Multiplexer (MUX)** are added into design to enable data selection (0 or 1) at every node which toggled by pattern inputs.
![Controllability](https://user-images.githubusercontent.com/62828746/207980453-957561a6-239d-4e00-a2e0-9869c81271e2.jpg)


## **Observability in term of DFT**
* A node is observable, when the value at the node can be shifted out through scan patterns and can be observed through scan out ports. 
* Flip-flops are added into design to store data and enable changes in output corresponding to the toggling of a node obsevable at packaged pins.
![Observability](https://user-images.githubusercontent.com/62828746/207980443-51eac9cb-5c90-46d5-a5f7-0379bb2f9c1c.jpg)


## **DFT techniques are mainly classified into two types:**
+ **Ad-hoc techniques:** collection of techniques or set of rules in the chip design process learned from design experience to improve/accomplish design testability.
  * Avoid combinational feedback.
  * All flip flops must be initializable.
  * Partition a large circuit into small blocks.
  * Provide test control for the signals which are notcontrollable.
  * While designing test logic we have to consider theATE requirements.

+ **Structured techniques:** extra logic and signals are added to the circuit to allow the test according to some predefined procedure.
  * Scan: In the design all the flip flops are converted to scan flip flop.
  * Boundary Scan
  * Built-in self-test (MBist & LBist)

## **Scan based technique/ Scan-chains**
![Scan-chains](https://user-images.githubusercontent.com/62828746/207972544-9efebac7-6830-4e2f-b73c-9e1586507d2e.jpg)
*[Reference:Overview and Dynamics of Scan Chain Testing](https://anysilicon.com/overview-and-dynamics-of-scan-testing/)
* Scan chains are the elements in scan-based designs that are used to shift-in and shift-out test data. 
* Scan chains: scan flip-flops are connected together in form of a chain.
* Scan flops: normal input (D) of the flip-flop are multiplexed with the scan input. Scan-enable signal is used to control which input will propagate to the output.
* When scan_enable port = 0 : data at D pin of the flop will propagate to Q at the next active edge.
* When scan_enable port = 1 : data present at scan-in input will propagate to Q at the next active edge.
+ Purpose of scan flops:
  * To test stuck-at faults in manufactured devices.
  * To test the paths in the manufactured devices for delay. (to test whether each path is working at functional frequency or not)

![Waveform without fault](https://user-images.githubusercontent.com/62828746/207972548-b3ed8eff-8bc8-4279-86d9-a6a4cdba4c7e.jpg)

+ Scan chain operation involves three stages:
  * Scan-in/Assert scan_enable: test patterns are loaded keeping the design in test timing mode.
  * Scan-capture: design is kept in functional timing mode and test pattern response is captured.
  * Scan-out/De-assert scan_enable: design is brought back in test timing mode and test pattern response is unloaded.

## **Functionality of scan-chain**
* Scan chains is to make each node in the circuit controllable and observable through limited number of patterns by providing a bypass path to each flip-flop.
* Scan chain is slightly different for slow capture (**Stuck-At faults**) and at speed capture (**Path Delay or Transition faults**).

**Scan-in**
* 1.SE is kept high (asserted) enables the scan mode and scan flip flop take SI value as inputs.
* 2.Test patterns will serially enter from the scan input port and enter first flip-flop of the scan chain.
* 3.At each active clock edge, it will shift to the next stage of flip-flop (shift register behaviour).
* 4.All scan chain elements will be loaded with the correct test patterns. 

![Stuck-At faults](https://user-images.githubusercontent.com/62828746/207972546-4f2ef6a3-334b-40d4-a87b-1106c588e818.jpg)

**Capture of stuck-at Testing**
*done at a slower frequency hence one pulse of clock*
* 1.SE is de-asserted, flip-flops works in normal functional timing mode and the test pattern response processed by the combinational logic is captured at the next stage of the flip-flop.
* 2.Before arrival of next active clock edge, the test pattern response is processed by the combinational logic and becomes available at the D input of next flip-flop.
* 3.At next positive clock edge, the processed test pattern response is captured by the next flip-flop and becomes available at the Q and SO pin.

![Path Delay or Transition faults](https://user-images.githubusercontent.com/62828746/207972535-7f8d92b8-0439-4e33-872f-4044be503c83.jpg)

**Captureof Speed-Transition/Path delay Testing**
*Testing is done at functional speed therefore the design is put in the function timing mode at functional frequency.* 
*This will require two or more functional clock pulses in the capture mode.*
* 1.SE is de-asserted, flip-flops works in normal functional timing mode.
* 2.Test pattern data is launched from D to Q pin of the flop at first capture pulse.
* 3.Test pattern data is captured by the next flip flop at second capture pulse, reached Q pins and SO pin of the subsequent flip-flop in the scan chain.
* 4.First clock pulse is launching the test pattern to the targeted combinational logic and second clock pulse ensures that combinational logic is getting at speed processing time.

**Scan-out**
* 1.SE is re-asserted in this mode, design is back to test timing mode.
* 2.At posedge clock edge, the captured data (test pattern response processed by the combinational logic) is serially shifted out on the scan chain.
* 3.Test pattern response captured at the SI pins of the flip-flops and was shifted serially out to the scan output port.
* 4.Compare output value with expected result.

## **Automated test equipment (ATE)**
* Automated test equipment (ATE) is a testing apparatus designed to perform a single test or sequence of tests on one or multiple devices at a time.
* The main goal of ATE is to ensure that an electronic device works as intended.
* The raw data captured by the test instruments is monitored, analyzed, and stored using the master controller’s signal sources and test software. Output readings are used to determine whether changes to the device need to be made or it's ready to be go.
* ATE frequently used by semiconductor manufacturers to test microprocessors, memory chips and analog integrated circuits.

**Basic automate testing system**

![Basic Automated Test System](https://user-images.githubusercontent.com/62828746/207969107-474e4002-e9ad-44b5-8d43-79cea19f357a.jpg)

* **Test controller:** implements test coding which runs the test system. 
* **Testing devices and testing instruments:** offer power and testing signals to the unit under testing and calculating the operation features of the module over the testing.
* **Test fixtures:** interlinks to the automated testing network to the UUT or unit under test.
* **Switching controller:** defines instructions from the test controller to manage the switching circuits that interlinks the testing device and test instrument with the certain testing points at the UUT.
* **Switching circuitry:** interlinks the testing devices and testing modules to certain positions known as the testing point at the module over which the test is done.
* **UUT:** can be one element, circuitry board or hole electronics packaging.

**Basic ATE functionality**
* 1. Scan-In Phase: control flip-flop operation in the serial shift state by scan enable signals
* 2. Parallel Measure: scan enable is invalid, and circuit working is in normal condition. Send basic input signal (primary input) from the input port of circuit this moment, and do not produce clock pulse, thereby trigger output constant.
* 3. Parallel Capture: circuit still is operated under the normal condition.ATE produces a clock pulse at this moment, and the virtual basic output signal of the D end of the trigger that previous step is produced captures the Q end of trigger.
* 4. First Scan-Out Phase: scan enable signals is effective, and flip-flop operation is in serial output mode, but ATE does not produce clock pulse.
* 5. Scan-Out Phase: circuit working is in serial output mode, after producing N clock, just obtain the total data of virtual basic output signal from SO port, squeeze into next test and excitation vector (test signal) from SI port simultaneously.

*[Reference:Method for increasing tested failure coverage of circuit](https://patents.google.com/patent/CN1381878A/en)


## **How DFT can be game changer for VLSI engineers**
* VLSI chips are reducing size and thickness day to day. Reduced in chip size with large number of transistor inside cause chip density increased. High chance this will casue issues during chip design flow. 
* DFT can help to check whether it's designed and working in expected way in early stage, which can help to reduce cost and time delay compared to finding bugs in post-fabrication stage.
* Faulty chips can cause huge loss to company hence DFT is important for improving chips quality that are being sold in the market.

  </details>

  
## Day 6
## Theory - Introduction to Logic Synthesis

<details open><summary> Digital logic </summary>
  
## **Digital logic**
* **Switching function:** voltage level in digital logic circuit are assumed to be switching from one value to another value instantaneously.
* **Automation and decision making:** logic gate perform logic operation which conduct logic decisions and the output depends on preset conditions.
* Behavioral model of the design are written in HDL (VHDL and Verilog).
 
  </details>

<details open><summary> What is logic synthesis </summary>
 
## **What is logic synthesis**
![What is logic synthesis](https://user-images.githubusercontent.com/62828746/208393821-1aac68f0-79e0-4fff-adf4-bb8fb02ae5a2.jpg)

* Synthesis is a process of converting RTL into gate level translation
* Logic synthesis is combining primitive logic functions to form a design netlist that meets functional and design goals.
* Basic steps (Translation > Logic optimization > Gate level mapping)
* Synthesis output: Gate-level netlist
 
  </details>
  
<details open><summary>Constraints (.sdc)</summary>
 
## **Constraints (.sdc)**
* Constraint is a set of rule that set limit on circuit parameters according to parameter priorities and requirements (in term of functional, timing, area and power). 
* Optmization steps in synthesis is constraint driven. 

   </details>

<details open><summary> Standard cell library (.lib) </summary>
  
## **Standard cell library (.lib)**
* Designer need to set priority design constraints and synthesis tool will choose **combinational library cells from .lib** that met design's requirement. 
* .lib consists of various basic gates with different flavours.
 
   </details>
   
   
<details open><summary> Why we need different flavours of gate? </summary>
 
### **Why we need different flavours of gate?**
As per mentioned in previous session, flavours of gate will effect ciruit operation speed:
[How Flavours of Gate Effect Ciruit Operation Speed](https://github.com/teoh5128/intel-sd-training#how-flavours-of-gate-effect-ciruit-operation-speed)

![Why we need different flavours of gate](https://user-images.githubusercontent.com/62828746/208393825-2536b926-9624-42dc-bdab-5c4e31c8e7c5.jpg)

* Comninational delay (TCOMBI) in logic path determines speed of operation of digtial logic circuit (FCLK).
* Different flavours of gates in .lib help synthesis tool to choose combinational cells that mets delay requirement (TCOMBI).
* Not only fast cells we also need slow cells.
 
   </details>
   
<details open><summary> Why we need slow cells? </summary>
 
### **Why we need slow cells?**

![Why we need slow cells](https://user-images.githubusercontent.com/62828746/208393829-d7ad1eec-ac76-4a27-911d-0d24483c3fbe.jpg)

* **Setup time:** amount of time the data at the synchronous input (D) must be stable before the active edge of clock
* **Hold time:** amount of time the data at the synchronous input (D) must be stable after the active edge of clock.
* **Hold time violation:** ouput data from previous cycle (DFFA) reach next flip flop input too early causing new data might not correctly stored in flip-flop (DFFB).
* To ensure there's no **hold issues**, we need cells that work slowly.
* This is why we need cells in different flavours, fast cell to meet performance and slow cell to meet hold.

   </details>
   
<details open><summary> Trade Off of Fast Cell and Slow Cell </summary>
 
## **Trade Off of Fast Cell and Slow Cell**
**Key**              | **Fast Cell**                                   | **Slow Cell**
------------------   | ---------------------------------------------   | --------------------------------------------- 
Capacitance | Faster charge/discharge | Slower charge/discharge
Transistor | Wider, capable sourcing more current | narrow, not capable sourcing more current
Delay | Lower | Higher
Area used | Higher | Lesser
Power used | Higher | Lesser
Used for | High frequency circuit | Meet hold time

  </details>

<details open><summary> Comparison of implementation </summary>
 
## **Comparison of implementation**

![Comparison of implementation](https://user-images.githubusercontent.com/62828746/208427485-dd5a074e-8152-4885-a529-bb2e8987200a.jpg)

* Different logic circuit implementation results in different area and delay value.
* There can have various type of combinational logic gates to implement Boolean function.
* Based on the 3 type of implementation above, type 3 which use lower area and delay might be the best choice.
* But if logic is present in **hold sensitive path**, an **additional delay buffers** are required to meet hold. These will result in additional area.


* **In shorts, different cell flavour and logic implementation are required to meet different design specification.**

     </details>
   
<details open><summary> Goals of synthesis </summary>
 
## **Goals of synthesis**
+ To get a Gate-level netlist which is:
  * **Logically correct** - Logic equivalence between RTL and netlist, logic optimization
  * **Electrically correct** - Inserting DFT logic
  * **Met timing** - Inserting clock gates
 
     </details>
     
## Theory - Introduction to Design Compiler (DC)

<details open><summary> Design Compiler (DC) </summary>
 
## **Design Compiler (DC)**
![Design Compiler (DC)](https://user-images.githubusercontent.com/62828746/208424612-dab6abb8-488c-42b3-a47e-7e84db1b3ac3.jpg)

* DC is the core synthesis engine of Synopsys synthesis product family.
* Used for logic synthesis which convert design description (written in Verilog or VHDL) into optimized gate-level netlist mapped to specific technology library.
+ 4 basic steps for synthesizing a design: 
  * Analyze & Elaborate
  * Apply Constraints
  * Optimization & Compilation
  * Inspection of Results
 
     </details>
     
<details open><summary> Common terminologies associated with DC </summary>
 
## **Common terminologies associated with DC:**
+ **SDC (Synopsys Design Constraints)**
  * Industry standard and suppoted by different EDA (Electronic Design Automation) tools implementation tools.
  * From Synopsys but can be understood by other EDA tools such as Cadence and Mentor Graphic.
  * As guidance for Synopsys tool to pick what flavours of cell and optimization type to achieve best implementation result.
  * Design intent in terms of timing, area and power constraints.
  * SDC is based on TCL. (Tool Command Language)

+ **.LIB**
  * Design library which contains collection of standard cells in various flavour. 
  * But cannot understand by DC, need to be converted to .db.

+ **.DB**
  * Same as .lib but in different format.
  * Can be understand by DC.

+ **DDC**
  * Synopsys proprietary format for storing design information.
  * It's a binary file which contains both verilog gate level description and design constrains.
  * DC can write out and read in DDC.

+ **Design**: RTL files which contains behavioral model of design.

  </details>
    
<details open><summary> Implementation Flow of ASIC (Application Specific Integrated Circuit) </summary>
 
## **Implementation Flow of ASIC (Application Specific Integrated Circuit)**
![Implementation Flow of ASIC](https://user-images.githubusercontent.com/62828746/208424595-112999c9-f5f9-4092-a276-556a4ec89aa8.jpg)
* ASIC design flow adopted by engineers for efficient structured ASIC chip architecture and focus on its design functionalities.
* It's a steps in converting RTL to the Physical Database (GDS).
* Synthesized netlist, design constraints and standard cell library are taken as inputs and converted to a layout (gds file).
+ Difference of ASIC and SoC (System On Chip):
  * ASIC - chips basically hardwired to do a specific task. Not applicable for general-purpose task.
  * Soc - collection of different type of processor components (ex: CPU/Modems and memory units).
 
  </details>

<details open><summary> DC Synthesis Flow </summary>
 
## **DC Synthesis Flow**
![DC Synthesis Flow](https://user-images.githubusercontent.com/62828746/208424605-590f8d17-f5e9-4b98-9db3-3ed2caab180e.jpg)
* Synthesis is a **process of converting RTL into a technology specific Gate level netlist** which includes nets, sequential cells, combinational cells and their connectivity.
+ There are 2 types of synthesis:
  * **Logical synthesis:** convert RDT to Gate level netlist. Includes gate mapping and optimization (timing/area/power) steps.
  * **Physical synthesis:** transform Gate level netlist to a layout that can be implemented on silicon. Includes floorplanning, placement, routing, clock tree synthesis and multiple different steps of local and global optimizations.

  </details>

## Theory - TCL quick refresher

<details open><summary> Basic TCL Command Used in DC </summary>

## **Basic TCL Command Used in DC**
**TCL command**      | **Function**                                   | **Example**
------------------   | ---------------------------------------------   | --------------------------------------------- 
set | to create and store information in variabels | *set a 5* -> assigned a = 5  <br />  *set a [expr $a + $b]* -> assign a = a + b  <br /> #square bracket used for nesting command
if loop | If Boolean expression evaluates true, then if block of code will be executed, otherwise else block of code will be executed. | Syntax and example code of an 'if...else' statement <br /> ![if_loop](https://user-images.githubusercontent.com/62828746/208475719-a58e6e77-2bb6-42a8-b852-d0292f0c44b4.jpg)
while loop | It evaluates test as an expression. If test is true, the code in body is executed. After the code in body has been executed, testis evaluated again. |  Syntax and example code of an 'while' statement <br /> ![while_loop](https://user-images.githubusercontent.com/62828746/208477034-f76b3762-6afe-4d0f-b74d-10383710bb0e.jpg)
for loop | A repetition control structure that allows code written to be executed for a specific number of times. |  Syntax and example code of an 'for' statement <br /> ![for_loop](https://user-images.githubusercontent.com/62828746/208478176-f27a59ad-a641-476d-8801-7ab3058f0e22.jpg)
foreach | Implements a loop where the loop variable(s) take on values from one or more lists. | Syntax and example code of an 'foreach' statement <br /> ![foreach_loop](https://user-images.githubusercontent.com/62828746/208479912-f4dfe426-5f30-4813-a871-05bdd0889f05.jpg)
foreach_in_collection | Similar to the foreach, just it was used to iterate through all elements in a collection instead of lists | Syntax and example code of an 'foreach_in_collections' statement <br /> ![foreach_in_collection](https://user-images.githubusercontent.com/62828746/208481531-8230cf9d-8fe9-49f6-ae6c-319014223ac2.jpg)

  </details>
        
## Lab Topic - Introduction to Logic Synthesis

<details open><summary> DC_D1SK2_L1 - lab1 - Invoking dc basic setup </summary>

### Lab - DC_D1SK2_L1 - lab1 - Invoking dc basic setup
#### Steps:
> 1. Go to home directory, create a folder for sd_training.
>> cd /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/
>> mkdir sd_training
> 2. Clone directory "sky130RTLDesignAndSynthesisWorkshop" from Kunal's github.
>> *git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git*
> 3. Explore copied directory and confirm there's all the required folders and files.
>> *cd sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP*
> 4. Goto lib/ and make sure "sky130_fd_sc_hd__tt_025C_1v80.db" lib is inside.
>> *cd lib/*
> 5. Goto verilog_files which stored all the verilog and testbench fill that will be used in subsequent labs.
>> *cd verilog_files/*

 #### Result:
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_0](https://user-images.githubusercontent.com/62828746/208451379-0fcfde28-271c-4278-a89a-d18c5ab68f3b.jpg)
 
 #### Steps:
> 1. Open library file and review what contains in .lib file. [*DO NOT EDIT .LIB FILE, ONLY READ]
>> *vim /lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 2. Tips to switch off syntax for more pleasant review experience. 
>> *:syn off*
> 3. Look into the information contains in .lib, such as library name, power, voltage and temperature of cell.
 
 #### Result:
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_1](https://user-images.githubusercontent.com/62828746/208451395-8f487a2b-646c-47eb-ae52-3665aa99667e.jpg)

 
 #### Steps:
> 1. Invoke dc 
>> csh -> to enable c shell
>> dc_shell -> invoke dc compiler
> 2. Read verilog file using command.
>> *read_verilog DC_WORKSHOP/verilog_files/lab1_flop_with_en.v*
> 3. Write verilog 
>> *write -f verilog -out lab1_net.v*
> 4. Read db and point to to correct path so that fix can't link library issues.
>> *read_db DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> *set target_library /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> *set link_library {* /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db}*
>> *link*
> 5. Compile the design
>> *compile*
> 6. Now, write verilog again which should be using cell inside sky130_fd_sc_hd__tt_025C_1v80.db.
>> *write -f verilog -out lab1_net_with_sky130.v*
> 7. Write in ddc format
>> *write -f ddc -out lab1.ddc*

#### Result:
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_2](https://user-images.githubusercontent.com/62828746/208451398-4d509a34-d1dd-4996-a25a-6c702838f490.jpg)
*Invoke dc shell and read_verilog*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_3](https://user-images.githubusercontent.com/62828746/208451403-93f3248c-045f-435d-b84d-0b992d124cd5.jpg)
*Read verilog file lab1_flop_with_en.v*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_4](https://user-images.githubusercontent.com/62828746/208451406-3d69a653-ae30-4c2d-8db0-5dd44c35e05f.jpg)
*Review written verilog file which used GTECH library.*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_5](https://user-images.githubusercontent.com/62828746/208451413-7f58fe6b-2aa3-4e6c-a1bf-665143e05b28.jpg)
*Read db and point to to correct path*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_6](https://user-images.githubusercontent.com/62828746/208451416-36ab88a9-476e-4ae2-8d3d-854264d63fce.jpg)
*Review written verilog file which used correct library path sky130_fd_sc_hd__tt_025C_1v80.db*
 
   </details>
   
<details open><summary> DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision </summary>

### Lab - DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision

#### Steps:
> 1. Launch design vision
>> *csh*
>> *design_vision*
> 2. In invoked design vision gui, use command to read ddc file.
>> *read_ddc lab1.ddc*
> 3. In logical hierarchy bar, right click and choose schematic view, double click the schematic moduel to see detail connection.

#### Result:
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_0](https://user-images.githubusercontent.com/62828746/208464654-bb84b2d8-d431-444e-b9fe-77b66e9eff7b.jpg)
*In invoked design vision gui, use command to read ddc file.*
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_1](https://user-images.githubusercontent.com/62828746/208464660-e81cc44b-4c9b-4903-95c2-6a88f668a44a.jpg)
*Comparison of read_verilog and read_ddc in design vison gui.*
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_2](https://user-images.githubusercontent.com/62828746/208464662-900e1049-c0b1-4d6f-beba-93d7f801a234.jpg)
*Schematic view of design lab1_flop_with_en.v*
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_3](https://user-images.githubusercontent.com/62828746/208464665-df404f0b-4db1-4300-9ba5-4d265cba0e70.jpg)
*Resulted schematic view is as expected.*
 
   </details>
   
   
   
<details open><summary> DC_D1SK2_L3 - lab3 - dc synopsys dc setup </summary>

### Lab - DC_D1SK2_L3 - lab3 - dc synopsys dc setup
#### Steps:
> 1. Invoke dc 
>> *csh* 
>> *dc_shell* 
> 2. To avoid tool using dummy library as default, set target library and link library everytime invoke dc.
>> *set target_library /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> *set link_library {* /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db}*
> 3. To avoid set multiple db files for design (which is troublesome and error prone) each time invoke dc, use command to replace installed default synopsys dc setup with home directory's synopsys dc setup. Then, all repetitive task (mainly target library and link library) which is needed for tool setup can be pointer in this file.
>> *cd <home directory>*
>> *gvim .synopsys_dc.setup*
> 4. Edit .synopsys_dc.setup file
>> set target_library /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> set link_library {* $target_library}
>> :qa! -> save file
> 5. Invoke dc shell again, will see target and link library auto set to sky130_fd_sc_hd__tt_025C_1v80.db.
>> csh
>> dc_shell
 
#### Result:
![DC_D1SK2_L3 - lab3 - dc synopsys dc setup_0](https://user-images.githubusercontent.com/62828746/208471728-ca45600d-2560-4ae8-8974-5e511612d00f.jpg)
*Invoke dc shell and manually set library path*
![DC_D1SK2_L3 - lab3 - dc synopsys dc setup_1](https://user-images.githubusercontent.com/62828746/208471736-f8ec2aa1-93a2-41e0-bbb7-4f2ef10daea5.jpg)
*Invoke dc shell after replace installed default synopsys dc setup with edited home directory's synopsys dc setup*

 </details>

<details open><summary> DC_D1SK3_L2 - lab4 - tcl scripting </summary>
 
### Lab - DC_D1SK3_L2 - lab4 - tcl scripting
 
#### Result:
![DC_D1SK3_L2 - lab4 - tcl scripting_0](https://user-images.githubusercontent.com/62828746/208494512-805be48a-d90b-4702-90f5-3b76c3842b0c.jpg)
 *Example of for loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_1](https://user-images.githubusercontent.com/62828746/208494518-bf5a0e2e-9380-4b3c-8e00-3969ae81855b.jpg)
 *Example of while loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_2](https://user-images.githubusercontent.com/62828746/208494522-21be38eb-6c4d-4e9b-87f6-bb1ee9cd6032.jpg)
 *Example of foreach loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_3](https://user-images.githubusercontent.com/62828746/208494525-aa6172c7-98f8-4c24-bb02-125a02aa2c2a.jpg)
 *Example of foreach_in_collection loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_4](https://user-images.githubusercontent.com/62828746/208494529-02a7836a-de9e-423a-b057-7837a821ec54.jpg)
 *Example of exprresion syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_5](https://user-images.githubusercontent.com/62828746/208494532-b8add567-b350-4e20-a7cb-a4dfda8a2a9f.jpg)
 *Example of print list use and no use foreach loop.*

 </details>


 
  
## Day 7 
## Theory - Introduction to STA


<details open><summary> Introduction to STA </summary>
 
## **Introduction to STA**
* **What is STA?:**
<br /> STA will adding net delays and cell delays to obtain path delays. Then, STA tool will analyze all paths from each start point to each end point, compare it against timing constraints set for the path and make sure it met the timing spec of design.
 
+ **Why we need STA?:**
  * STA helps to calculate path delay for optimization tool and help the tool to chose most optimcal cell from .lib to create a circuit that met timing constraints. 
  * STA helps to verify circuit working at specified frequency.

* **When will STA included in design flow?**
 <br /> STA is covered during Synthesis stage in ASIC design flow. To check whether design spec meet timing requirement without simulation.

![Delay](https://user-images.githubusercontent.com/62828746/209027821-346ad7d6-004d-44c4-92bc-74b95fc2fb0e.jpg)
 
+ Delay of a cell will be a function of **Input Transition** (Inflow)
  * Delay is function of current
  * Fast current/fast input: less delay/fast rise

+ Delay of a cell will be a function of output load 
  * Delay is function of load capacitance
  * Larger load: higher delay/slower transition time
 
 
![Timing arc](https://user-images.githubusercontent.com/62828746/209027829-dcb6dcd7-06eb-42ee-8c8a-05bedb9066f6.jpg)

* Timing arc: represents the timing relationship between 2 pins of any cell or block or any boundaries. And it defines the propogation of signal through logic gates.
* Basically it has a start point and end point.
+ Delay for sequential cell:
  * Delay from Clock to Q for D Flip Flop
  * Delay from Clock to Q, Delay from D to Q for D Latch
  * Setup and Hold time delay
 
* D to Q delay only happened for D latch.
* D latch sampling point start at where the D latch become opaque.

 
   </details>
 
## Theory - What are constraints?
<details open><summary> What are constraints </summary>

![timing path](https://user-images.githubusercontent.com/62828746/209027830-ee44f46c-5e6a-4809-900b-2a05dc6af6ff.jpg)

* **Critical path:** Path that deciding or limiting clock frequency
* Timing path 1 and 2 has different Tcombi delay, where timing path 1 that has higher delay become the critical path.
* Set a clock period value and synthesis will choose cells that meets the delay (Tcombi delay) -> constraint to design

 
![Constraints summary](https://user-images.githubusercontent.com/62828746/209027816-7b3625cb-922a-44fb-8c2c-1d24d6dd4d40.jpg)

+ Timing path always start at one start point and end at one of the end points
  * CLK to D - start:clock pins of register, end:D pins of DFF/D-Latch
  * Clk to Output - start:clock pins of register, end:output port
  * Input to D - start:input port, end:D pins of DFF/D-Latch
  * Input to Output - start:input port, end:output port
* inA/InB/OutY: interface at the boundary of whole chip (module)
+ Type of timing paths:
  * Reg2Reg: constrained by clock (eg: CLK to D)
  * Reg2Out: constrained by output external delay and clock perios ( IO path, eg: Clk to Output)
  * In2Reg:  constrained by internal external delay and clock perios ( IO path, eg: Input to D)
* IO Delay Modelling: Delay modelling that referred IO timing path and IO budgeting is based on the interaction with other modules outside the module bundary.

 
   </details>
 
## Theory - Inp Trans Output Load
<details open><summary> Inp Trans Output Load </summary>

![Model transition delay](https://user-images.githubusercontent.com/62828746/209027827-0052c41e-f37b-4453-913e-3d416a4723a6.jpg)

* For ideal case, transition delay is not counted in and this might cause input logic delay will increased (due to add in trans delay).
* This will cause setup time for next capturing flip flop violated.
* Hence, we need to model input transition delay to avoid setup violation for next capturing DFF.
* Specification of design will tell the tools how much should the delay (transition and load) be modelled, depends on the distance with other module.
* It should be optimally and correctly modelled cause over modelling of delay will give negative returns which is not looking forward to.

![Model output load delay](https://user-images.githubusercontent.com/62828746/209027824-007ca258-ef77-4ff5-a279-49c91e1beaac.jpg)

* For ideal case, ouput load delay is not counted in and this might cause output logic delay will increased (due to add in output load delay).
* This will cause setup time for next capturing flip flop violated.
* Hence, we also need to model output load delay to avoid setup violation for next capturing DFF.
* Always remember: **delay of cell is the function of Input Transition and Output Load.**
 
   </details>



## Lab Topic - Basics of STA

<details open><summary> DC_D2SK2_L1 - Lab5 - Timing dot Libs </summary>

### Lab - DC_D2SK2_L1 - Lab5 - Timing dot Libs
#### Steps:
> 1.Open .lib file and review the information.
>> *gvim sky130_fd_sc_hd__tt_025C_1v80.lib*

 #### Result:
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_0](https://user-images.githubusercontent.com/62828746/209026589-fb54710e-dd1f-44ad-b153-4f120f6920f4.jpg) 

 *Review delay model and default maximum transition inside .lib*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_1](https://user-images.githubusercontent.com/62828746/209026593-a557f509-bdd4-48d1-a584-521292fa4b67.jpg) 

 *More input driver, area higher, transistor wider and delay lower.*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_2](https://user-images.githubusercontent.com/62828746/209026595-1c81d70b-fce3-485e-b2b3-9d9d664b01b5.jpg) 

*Review other cell pin's attribute inside .lib*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_3](https://user-images.githubusercontent.com/62828746/209026597-59260329-4fdc-4e90-b2ea-ef3214f00597.jpg) 
 
*Effect of area of cell and load capacitance to delay of cell*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_4](https://user-images.githubusercontent.com/62828746/209026598-d5e51bbd-014d-4782-811e-ee7103bc4004.jpg) 
 
*Tools use unateness to propogate the transition of cell.*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_5](https://user-images.githubusercontent.com/62828746/209026600-d2d63b73-669c-41e6-81bc-3e1692a3cd73.jpg) 
 
*Example of Unatness for various cells*
 
   </details>
   
   

<details open><summary> DC_D2SK2_L2 - Lab6 - Exploring dotLib </summary>
 
### Lab - DC_D2SK2_L2 - Lab6 - Exploring dotLib
#### Steps:
> 1.Open .lib file and review the information.
>> *gvim sky130_fd_sc_hd__tt_025C_1v80.lib*
> 2. Load dc shell to get sequential library cell name
>> csh
>> dc_shell
>> *get_lib_cells */* -filter "is_sequential==true"*
 
#### Result:
![DC_D2SK2_L2 - Lab6 - Exploring dotLib_0](https://user-images.githubusercontent.com/62828746/209026602-f8741a38-64ad-4c97-84ae-20d816d45974.jpg)

 *Attribute/constraints set for DFF*
 
![DC_D2SK2_L2 - Lab6 - Exploring dotLib_1](https://user-images.githubusercontent.com/62828746/209026604-efd93363-6678-406c-86b0-bee20044c543.jpg)

 *Timing type for posedge DFF (dlrtp) and negedge DFF (dlrtn)*
 
   </details>
   
   
<details open><summary> DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2 </summary>
 
### Lab - DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2
 
#### Steps:
>1.List what library has linked
>> *list_lib*
>2.Sort out all "AND" cell name inside library
 
`foreach_in_collection my_lib_cell [get_lib_cells */*and*] {                                                                        
set my_lib_cell_name [get_object_name $my_lib_cell];
echo $my_lib_cell_name;
}
`
>3.Sort out all "AND" cell name that are inside library with pin direction
 
`foreach_in_collection my_pins [get_lib_pins sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_0/*] {
set my_pin_name [get_object_name $my_pins];
set pin_dir [get_lib_attribute $my_pin_name direction];
echo $my_pin_name $pin_dir;
}
`

#### Result:
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_0](https://user-images.githubusercontent.com/62828746/209026606-00b28107-5aae-40ba-b0a2-ea81a6ba4883.jpg)

 *List out all the “AND” cell’s name inside library*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_1](https://user-images.githubusercontent.com/62828746/209026607-76ce8db8-2770-47e4-8f04-4f6ee84edbc8.jpg)

 *Sort out all "AND" cell name that are inside library*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_2](https://user-images.githubusercontent.com/62828746/209026612-5e68d495-41cf-4183-8c16-421c1909deb2.jpg)

 *Sort out all "AND" cell name that are inside library with pin direction*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_3](https://user-images.githubusercontent.com/62828746/209026614-a9864a77-7d05-4c99-9880-f6bc6e21b458.jpg)

 *Script to sort out pin’s name, direction and function*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_4](https://user-images.githubusercontent.com/62828746/209026618-85317b19-28d2-4a6d-b89a-021b07bc06c8.jpg)

 *Command that able to quickly explore attribute of cell’s pins*
 
   </details>
 
 
